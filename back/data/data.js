/**
 * What a user looks like in database
 * @typedef {Object} User
 * @property {string} first The first name
 * @property {string} last The last name
 * @property {string} email The email
 * @property {string} company The company
 * @property {string} country The country
 * @property {number?} id The id (generated by business)
 * @property {string?} created_at The date of creation (generated by business) 
 */

/**
 * Importation des modules
 */

const fs = require("fs");

// ----- Constantes de la base de donnÃ©e

const DATABASE = __dirname + "/users.json";

// ----- Utils -----

/**
 * Get the last index given
 * @param {User[]} users Array of all users
 * @returns {number} The last index of users
 */
const get_last_index = users => Math.max(...users.map(user => user.id), 0);

/**
 * Get all users from database
 * @returns {User[]} Array of all users
 */
const read_database_file = () => JSON.parse(fs.readFileSync(DATABASE, "utf8"));

/**
 * Write users in database
 * @param {User[]} users Array of all users
 */
const write_database_file = users => fs.writeFileSync(DATABASE, JSON.stringify(users), "utf8");

// ----- Fonctions publiques -----

const data_public = {
    /**
     * Get all users from database
     * @returns {User[]} Array of all users
     */
    getAllUsers: () => read_database_file(),
    /**
     * Add a user to database
     * @param {User} user The user to add to database (verified)
     * @returns {boolean} Is the user added ?
     */
    addUser: (user) => {
        let users;
    
        // Read users and return false on error
        try {
            users = read_database_file();
        } catch {
            console.error("Couldn't read from database");
            return false;
        }

        // Add user info
        user.id = get_last_index(users) + 1;
        user.created_at = new Date().toUTCString();

        // Add user to user array
        users.push(user);
        
        // Write users and return false on error
        try {
            write_database_file(users);
        } catch {
            console.error("Couldn't write in database");
            return false;
        }
        
        return true;
    },
    /**
     * Edit a user in database
     * @param {{id: number, to_edit: User}} user The user to edit
     * @returns {boolean} Is the user edited ?
     */
    editUser: (user) => {
        let users;
    
        // Read users and return false on error
        try {
            users = read_database_file();
        } catch {
            console.error("Couldn't read from database");
            return false;
        }

        // Get index
        let user_index = -1;
        for (let i = 0 ; i < users.length ; i++) {
            if (users[i].id == user.id) {
                user_index = i;
            }
        }

        // User not found
        if (user_index == -1) {
            return false;
        }

        // Edit user
        for (let key in user.to_edit) {
            users[user_index][key] = user.to_edit[key];
        }

        // Write users and return false on error
        try {
            write_database_file(users);
        } catch {
            console.error("Couldn't write in database");
            return false;
        }

        return true;
    },
    /**
     * Delete a user from database
     * @param {number} id The id of the user to delete
     * @returns {boolean} Is the user deleted ?
     */
    delUser: (id) => {
        let users;
    
        // Read users and return false on error
        try {
            users = read_database_file();
        } catch {
            console.error("Couldn't read from database");
            return false;
        }

        // Check if id is in users
        if (users.map(user => user.id).indexOf(id) == -1) {
            return false;
        }

        // Delete user with given id
        users = users.filter(user => user.id != id);

        // Write users and return false on error
        try {
            write_database_file(users);
        } catch {
            console.error("Couldn't write in database");
            return false;
        }

        return true;
    }
}

module.exports = data_public;